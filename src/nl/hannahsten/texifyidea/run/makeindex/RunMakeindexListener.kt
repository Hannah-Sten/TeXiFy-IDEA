package nl.hannahsten.texifyidea.run.makeindex

import com.intellij.execution.RunnerAndConfigurationSettings
import com.intellij.execution.impl.RunConfigurationBeforeRunProvider
import com.intellij.execution.impl.RunManagerImpl
import com.intellij.execution.process.ProcessEvent
import com.intellij.execution.process.ProcessListener
import com.intellij.execution.runners.ExecutionEnvironment
import com.intellij.openapi.application.runReadAction
import com.intellij.openapi.progress.ProgressManager
import com.intellij.openapi.util.Key
import com.intellij.openapi.util.io.FileUtil
import nl.hannahsten.texifyidea.lang.LatexLib
import nl.hannahsten.texifyidea.run.compiler.MakeindexProgram
import nl.hannahsten.texifyidea.run.latex.LatexConfigurationFactory
import nl.hannahsten.texifyidea.run.latex.LatexRunConfiguration
import nl.hannahsten.texifyidea.run.latex.getDefaultMakeindexPrograms
import nl.hannahsten.texifyidea.run.latex.getMakeindexOptions
import nl.hannahsten.texifyidea.util.appendExtension
import nl.hannahsten.texifyidea.util.files.psiFile
import nl.hannahsten.texifyidea.util.includedPackagesInFileset
import nl.hannahsten.texifyidea.util.magic.FileMagic
import java.io.File
import java.io.FileNotFoundException
import java.io.IOException

/**
 * Run makeindex and then latex again (twice).
 */
class RunMakeindexListener(
    private val latexRunConfig: LatexRunConfiguration,
    private val environment: ExecutionEnvironment,
    private val filesToCleanUp: MutableList<File>
) : ProcessListener {

    override fun processTerminated(event: ProcessEvent) {
        try {
            // Only create new one if there is none yet
            val runConfigSettingsList =
                latexRunConfig.makeindexRunConfigs.ifEmpty {
                    val configs = mutableSetOf<RunnerAndConfigurationSettings>()
                    // We need index access, which has to be done in EDT but we cannot run slow operations in EDT
                    ProgressManager.getInstance().runProcessWithProgressSynchronously(
                        { configs.addAll(generateIndexConfigs()) },
                        "Generating Makeindex Run Configuration...",
                        false,
                        latexRunConfig.project,
                    )
                    configs
                }

            // Run all run configurations
            for (runConfigSettings in runConfigSettingsList) {
                val makeindexRunConfig = runConfigSettings.configuration as MakeindexRunConfiguration
                val options = getMakeindexOptions(makeindexRunConfig.mainFile, makeindexRunConfig.project)
                val baseFileName = options.getOrDefault("name", makeindexRunConfig.mainFile?.nameWithoutExtension) ?: return

                // Because bib2gls needs the bib file, and we do not want to guess the location of the bib file(s) to copy,
                // we choose to copy the aux file first and then run bib2gls next to the main file
                // In comparison: other makeindex programs we run in the auxil dir and then copy the output files (like .ind)
                if (makeindexRunConfig.makeindexProgram == MakeindexProgram.BIB2GLS) {
                    copyIndexOutputFiles(baseFileName, FileMagic.bib2glsDependenciesExtensions)
                }

                // Run makeindex
                RunConfigurationBeforeRunProvider.doExecuteTask(environment, runConfigSettings, null)

                copyIndexOutputFiles(baseFileName, FileMagic.indexFileExtensions)
                copyBib2glsOutput(makeindexRunConfig, baseFileName)
            }

            scheduleLatexRuns()
        }
        finally {
            latexRunConfig.isLastRunConfig = false
            latexRunConfig.isFirstRunConfig = true
        }
    }

    /**
     * .glstex is generated by bib2gls, we could clean it up but copy to output folder instead just in case
     */
    private fun copyBib2glsOutput(makeindexRunConfig: MakeindexRunConfiguration, baseFileName: String) {
        if (makeindexRunConfig.makeindexProgram == MakeindexProgram.BIB2GLS) {
            try {
                val mainFile = latexRunConfig.mainFile
                val auxilDir = latexRunConfig.getAuxilDirectory()
                if (mainFile != null && auxilDir != null && mainFile.path != auxilDir.path) {
                    for (extension in setOf("glstex", "glg")) {
                        FileUtil.rename(File(mainFile.parent.path + '/' + baseFileName.appendExtension(extension)), File(auxilDir.path + '/' + baseFileName.appendExtension(extension)))
                    }
                }
            }
            catch (ignored: IOException) {}
        }
    }

    private fun scheduleLatexRuns() {
        // Don't schedule more latex runs if bibtex is used, because that will already schedule the extra runs
        if (latexRunConfig.bibRunConfigs.isEmpty()) {
            // LaTeX twice
            latexRunConfig.isFirstRunConfig = false
            val latexSettings = RunManagerImpl.getInstanceImpl(environment.project).getSettings(latexRunConfig)
                ?: return
            latexRunConfig.isLastRunConfig = false
            RunConfigurationBeforeRunProvider.doExecuteTask(environment, latexSettings, null)
            latexRunConfig.isLastRunConfig = true
            RunConfigurationBeforeRunProvider.doExecuteTask(environment, latexSettings, null)
        }
    }

    private fun generateIndexConfigs(): Set<RunnerAndConfigurationSettings> {
        val runManager = RunManagerImpl.getInstanceImpl(environment.project)

        val usedPackages = runReadAction {
            latexRunConfig.mainFile?.psiFile(environment.project)?.includedPackagesInFileset() ?: emptySet()
        }
        val mainFile = latexRunConfig.mainFile
        val indexPrograms = getDefaultMakeindexPrograms(mainFile, environment.project, usedPackages)

        val runConfigs = mutableSetOf<RunnerAndConfigurationSettings>()

        for (indexProgram in indexPrograms) {
            val makeindexRunConfigSettings = runManager.createConfiguration(
                "",
                LatexConfigurationFactory(MakeindexRunConfigurationType())
            )

            val runConfig = makeindexRunConfigSettings.configuration as MakeindexRunConfiguration

            runConfig.mainFile = mainFile
            runConfig.makeindexProgram = indexProgram
            runConfig.setSuggestedName()
            // See nomencl documentation
            if (LatexLib.NOMENCL in usedPackages && indexProgram == MakeindexProgram.MAKEINDEX) {
                runConfig.commandLineArguments = "${mainFile?.nameWithoutExtension}.nlo -s nomencl.ist -o ${mainFile?.nameWithoutExtension}.nls"
            }

            // bib2gls we handle separately, because it needs the bib file, so instead of running it in the auxil dir we run it next to the main file
            runConfig.workingDirectory = if (runConfig.makeindexProgram != MakeindexProgram.BIB2GLS) latexRunConfig.getAuxilDirectory() else runConfig.mainFile?.parent

            runManager.addConfiguration(makeindexRunConfigSettings)
            runConfigs.add(makeindexRunConfigSettings)
        }

        latexRunConfig.makeindexRunConfigs = runConfigs
        return runConfigs
    }

    /**
     * Copy .ind and similar files from where they were generated by makeindex to next to the main file, so an index package will hopefully find it.
     *
     * @param baseFileName Filename of generated files without extension.
     *
     * @return List of files that should be cleaned up.
     */
    private fun copyIndexOutputFiles(baseFileName: String, indexFileExtensions: Set<String>) {
        val mainFile = latexRunConfig.mainFile ?: return
        val auxilDir = latexRunConfig.getAuxilDirectory() ?: return
        val sourceDir = auxilDir.path + '/'
        val destinationDir = File(mainFile.path).parent + '/'

        if (sourceDir == destinationDir) return

        // Just try all extensions for files that need to be copied
        // Skips files that do not exist
        for (extension in indexFileExtensions) {
            val indexFileName = baseFileName.appendExtension(extension)
            val indexFileSource = File(sourceDir + indexFileName)
            if (!indexFileSource.isFile) continue
            val indexFileDestination = File(destinationDir + indexFileName)

            // Only clean up file if not copied there by user
            if (indexFileSource.exists() && !indexFileDestination.exists()) {
                filesToCleanUp.add(indexFileDestination)
            }

            try {
                FileUtil.copy(indexFileSource, indexFileDestination)
            }
            catch (ignored: FileNotFoundException) {
            }
        }
    }

    override fun onTextAvailable(p0: ProcessEvent, p1: Key<*>) {}

    override fun processWillTerminate(p0: ProcessEvent, p1: Boolean) {}

    override fun startNotified(p0: ProcessEvent) {}
}
