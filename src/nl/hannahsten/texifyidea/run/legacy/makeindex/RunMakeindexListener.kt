package nl.hannahsten.texifyidea.run.legacy.makeindex

import com.intellij.execution.RunnerAndConfigurationSettings
import com.intellij.execution.impl.RunConfigurationBeforeRunProvider
import com.intellij.execution.impl.RunManagerImpl
import com.intellij.execution.process.ProcessEvent
import com.intellij.execution.process.ProcessListener
import com.intellij.execution.runners.ExecutionEnvironment
import com.intellij.openapi.application.runReadAction
import com.intellij.openapi.util.Key
import com.intellij.openapi.util.io.FileUtil
import nl.hannahsten.texifyidea.lang.LatexPackage
import nl.hannahsten.texifyidea.run.LatexRunConfiguration
import nl.hannahsten.texifyidea.run.LatexTemplateConfigurationFactory
import nl.hannahsten.texifyidea.run.legacy.MakeindexProgram
import nl.hannahsten.texifyidea.run.step.getDefaultMakeindexPrograms
import nl.hannahsten.texifyidea.run.step.getMakeindexOptions
import nl.hannahsten.texifyidea.util.appendExtension
import nl.hannahsten.texifyidea.util.files.psiFile
import nl.hannahsten.texifyidea.util.includedPackages
import nl.hannahsten.texifyidea.util.magic.FileMagic
import java.io.File
import java.io.FileNotFoundException
import java.io.IOException

/**
 * Run makeindex and then latex again (twice).
 */
class RunMakeindexListener(
    private val latexRunConfig: LatexRunConfiguration,
    private val environment: ExecutionEnvironment,
    private val filesToCleanUp: MutableList<File>
) : ProcessListener {

    override fun processTerminated(event: ProcessEvent) {
        try {
            // Only create new one if there is none yet
            val runConfigSettingsList = emptyList<RunnerAndConfigurationSettings>()
//                if (latexRunConfig.makeindexRunConfigs.isEmpty()) {
//                    generateIndexConfigs()
//                }
//                else {
//                    latexRunConfig.makeindexRunConfigs
//                }

            // Run all run configurations
            for (runConfigSettings in runConfigSettingsList) {
                val makeindexRunConfig = runConfigSettings.configuration as MakeindexRunConfiguration
                val options = getMakeindexOptions(makeindexRunConfig.mainFile, makeindexRunConfig.project)
                val baseFileName = options.getOrDefault("name", makeindexRunConfig.mainFile?.nameWithoutExtension) ?: return

                // Because bib2gls needs the bib file, and we do not want to guess the location of the bib file(s) to copy,
                // we choose to copy the aux file first and then run bib2gls next to the main file
                // In comparison: other makeindex programs we run in the auxil dir and then copy the output files (like .ind)
                if (makeindexRunConfig.makeindexProgram == MakeindexProgram.BIB2GLS) {
                    copyIndexOutputFiles(baseFileName, FileMagic.bib2glsDependenciesExtensions)
                }

                // Run makeindex
                RunConfigurationBeforeRunProvider.doExecuteTask(environment, runConfigSettings, null)

                copyIndexOutputFiles(baseFileName, FileMagic.indexFileExtensions)
                copyBib2glsOutput(makeindexRunConfig, baseFileName)
            }

            scheduleLatexRuns()
        }
        finally {
//            latexRunConfig.isLastRunConfig = false
//            latexRunConfig.isFirstRunConfig = true
        }
    }

    /**
     * .glstex is generated by bib2gls, we could clean it up but copy to output folder instead just in case
     */
    private fun copyBib2glsOutput(makeindexRunConfig: MakeindexRunConfiguration, baseFileName: String) {
        if (makeindexRunConfig.makeindexProgram == MakeindexProgram.BIB2GLS) {
            try {
                val mainFile = latexRunConfig.options.mainFile.resolve()
                val auxilDir = latexRunConfig.getAuxilDirectory()
                if (mainFile != null && auxilDir != null && mainFile.path != auxilDir.path) {
                    for (extension in setOf("glstex", "glg")) {
                        FileUtil.rename(
                            File(mainFile.parent.path + '/' + baseFileName.appendExtension(extension)),
                            File(auxilDir.path + '/' + baseFileName.appendExtension(extension))
                        )
                    }
                }
            }
            catch (ignored: IOException) {
            }
        }
    }

    private fun scheduleLatexRuns() {
//        // Don't schedule more latex runs if bibtex is used, because that will already schedule the extra runs
//        if (latexRunConfig.bibRunConfigs.isEmpty()) {
// //             LaTeX twice
//            latexRunConfig.isFirstRunConfig = false
//            val latexSettings = RunManagerImpl.getInstanceImpl(environment.project).getSettings(latexRunConfig)
//                ?: return
//            latexRunConfig.isLastRunConfig = false
//            RunConfigurationBeforeRunProvider.doExecuteTask(environment, latexSettings, null)
//            latexRunConfig.isLastRunConfig = true
//            RunConfigurationBeforeRunProvider.doExecuteTask(environment, latexSettings, null)
//        }
    }

    private fun generateIndexConfigs(): Set<RunnerAndConfigurationSettings> {
        val runManager = RunManagerImpl.getInstanceImpl(environment.project)

        val usedPackages = runReadAction {
            latexRunConfig.options.mainFile.resolve()?.psiFile(environment.project)?.includedPackages() ?: emptySet()
        }
        val mainFile = latexRunConfig.options.mainFile.resolve()
        val indexPrograms = getDefaultMakeindexPrograms(mainFile, environment.project, usedPackages)

        val runConfigs = mutableSetOf<RunnerAndConfigurationSettings>()

        for (indexProgram in indexPrograms) {
            val makeindexRunConfigSettings = runManager.createConfiguration(
                "",
                LatexTemplateConfigurationFactory(MakeindexRunConfigurationType())
            )

            val runConfig = makeindexRunConfigSettings.configuration as MakeindexRunConfiguration

            runConfig.mainFile = mainFile
            // runConfig.mainFile = latexRunConfig.options.mainFile.resolve()
            runConfig.makeindexProgram = indexProgram
            runConfig.setSuggestedName()
            // See nomencl documentation
            if (LatexPackage.NOMENCL in usedPackages && indexProgram == MakeindexProgram.MAKEINDEX) {
                runConfig.commandLineArguments = "${mainFile?.nameWithoutExtension}.nlo -s nomencl.ist -o ${mainFile?.nameWithoutExtension}.nls"
            }

            // bib2gls we handle separately, because it needs the bib file, so instead of running it in the auxil dir we run it next to the main file
            runConfig.workingDirectory =
                if (runConfig.makeindexProgram != MakeindexProgram.BIB2GLS) latexRunConfig.getAuxilDirectory() else runConfig.mainFile?.parent

            runManager.addConfiguration(makeindexRunConfigSettings)
            runConfigs.add(makeindexRunConfigSettings)
        }

//        latexRunConfig.makeindexRunConfigs = runConfigs
        return runConfigs
    }

    /**
     * Copy .ind and similar files from where they were generated by makeindex to next to the main file, so an index package will hopefully find it.
     *
     * @param baseFileName Filename of generated files without extension.
     *
     * @return List of files that should be cleaned up.
     */
    private fun copyIndexOutputFiles(baseFileName: String, indexFileExtensions: Set<String>) {

        val mainFile = latexRunConfig.options.mainFile.resolve() ?: return
        val auxilDir = latexRunConfig.getAuxilDirectory() ?: return
        val sourceDir = auxilDir.path + '/'
        val destinationDir = File(mainFile.path).parent + '/'

        if (sourceDir == destinationDir) return

        // Just try all extensions for files that need to be copied
        // Skips files that do not exist
        for (extension in indexFileExtensions) {
            val indexFileName = baseFileName.appendExtension(extension)
            val indexFileSource = File(sourceDir + indexFileName)
            if (!indexFileSource.isFile) continue
            val indexFileDestination = File(destinationDir + indexFileName)

            // Only clean up file if not copied there by user
            if (indexFileSource.exists() && !indexFileDestination.exists()) {
                // todo instead of modifying run config instance variable, modify the file cleanup step at the end directly
                filesToCleanUp.add(indexFileDestination)
            }

            try {
                FileUtil.copy(indexFileSource, indexFileDestination)
            }
            catch (ignored: FileNotFoundException) {
            }
        }
    }

    override fun onTextAvailable(p0: ProcessEvent, p1: Key<*>) {}

    override fun processWillTerminate(p0: ProcessEvent, p1: Boolean) {}

    override fun startNotified(p0: ProcessEvent) {}
}